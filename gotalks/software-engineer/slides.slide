How to become a better software engineer
31 May 2017
Tags: internal

Gediminas Morkevicius
Software engineer at, DATA-DOG
gediminas.morkevicius@gmail.com
http://slides.gediminasm.org
@l3pp4rd



* Hello

I'm your dear colleague.

.image imgs/vim-go.png 300 _



* Agenda

- Lets define what is - great software engineer?
- How to be a hero?
- What engineering skills should we learn?
- Challenge yourself with some tasks.
- Some resources for learning stuff.



* Good news

It will not be that boring..

.image imgs/boring.jpg 400 _



* Social skills

You haven't thought this could be important for the software engineer, did you?

.image imgs/pulp-fiction.jpg 300 _

Well it is! Today is your lucky day, I'll tell you why..




* Not my problem skill

Imagine a situation:

- You go to the toilet.
- Do your *BIG* thing.



* And then you suddenly discover

.image imgs/no-paper.jpg 400 _




* Who should we blame?

- *A.* - Tim, who uses too much paper.
- *B.* - John, who left it empty.
- *C.* - Tom, who saw it empty, but thought - well, not my problem.
- *D.* - Jim, who saw it empty, but didn't knew where the spare paper is located and
left without telling anyone about the problem.

.image imgs/whos-guilty.jpg 300 _




* Well, actually no one!

Just get the *f-ckin* paper and replace it!




* And

.image imgs/brag.jpg 400 _

It takes all *lifetime* to build you as an *individual* in the eyes of others.




* Waiting for an Opportunity skill

Every day, there are loads of opportunities to be a *hero*.

Don't wait for something special. Replace the damn toilet paper.




* Even then

When there aren't any one around, watching you do it!




* Not my fault skill

Was there any chance, that you could have prevented something bad from happening?

.image imgs/not-my-fault.jpg 400 _




* Guess you got my point

Lets move on to some engineering skills.



* Software engineer should know some stuff

- Learn queues - Rabbit MQ, NSQ, Nats, Kafka
- Learn databases - MongoDB, RDBMS, Spanner, CockroachDB, Graph databases
- Learn *CAP* theorem. See https://jepsen.io/analyses
- Learn about transactions and consistency *ACID*
- Learn various software for metrics, like statsd or https://prometheus.io/
- Learn microservices and *OpenTracing*
- Learn how to deploy software *kubernetes*, *mesos*, *ansible*.

This is only a *needle* in the *haystack*.



* What about self Confidence

.image imgs/chart.jpg 400 _



* Systems design and Architecture

- What is this?
- What skills apply here?



* Lets make a challenge and design a System

Given *DATA-DOG* decides to build *SAS* for employee monitoring:

- Each employee computer should be monitored.
- When they are staring or finishing actively using a computer.
- Including web traffic, how much time they are spending on *delfi.lt*, *9gag.com* and etc.
- The tool reports statistics to a central service, which provides a dashboard for an organization admins.
- The tool on each employee computer, should often be updated with new features.



* Programming language

What should we choose for this software? Why?



* Database

What should we choose and why?



* MVP - minimum viable product

What should it be in this situation?



* What about security?

Should this tool encrypt sent data? Why?



* How can we make a reliable system?

- Data consistency, how should we store it?
- Scaling services
- How we deploy it?

Given we scale at 10000 companies and 500 employees each.



* Why is this important?

You may say, well I'm not a software architect.

But you still have to make decisions, even on dumb projects.

And each decision matters, it may create or reduce work.



* As a great engineer

- You have to learn a lot.
- Experience a lot of good and bad designs in order to make better decisions.

In software, there is no best decision - only *better* or *worse*.



* You should know when not to write code

It is far worse to write something, which could be avoided at all.



* You should always know what your Goals are

Knowing why you do stuff and the way you do it - is important.
Because the value is not in the amount of code, but in value it gives.



* The code is not an Art work

Just make it simple, stupid and understandable for everyone.
Clever code is always harder to maintain and extend on.

- Choose composition over inheritance.
- Choose explicit over implicit. AOP is a grave example.



* Some links

.link https://12factor.net/ Twelve Factor App
.link https://medium.com/@jlouis666/how-to-build-stable-systems-6fe9dcf32fc4 How to build stable systems
.link https://hackernoon.com/senior-engineers-reduce-risk-5ab2adc13c97 Senior engineers reduce risk



* About languages

Learn at least few programming languages.

*PHP* is not a language to solve all possible problems.

Make some challenges for your self, develop something challenging your skills.

Distributed and fault tolerant systems are hard.



* Some talks about architecture

.link https://aphyr.com/posts/343-scala-days-2017-jepsen-keynote Something to be aware about databases
.link https://www.youtube.com/watch?v=STKCRSUsyP0 Event Driven Architecture
.link https://www.infoq.com/presentations/Simple-Made-Easy Simple Made Easy
.link https://www.youtube.com/watch?v=wgdBVIX9ifA Microservices

